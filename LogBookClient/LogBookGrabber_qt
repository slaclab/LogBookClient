#!/usr/bin/env python

#--------------------------------------------------------------------------
# Description:
#   LogBookGrabber_qt.py
#------------------------------------------------------------------------
"""Qt-based GUI application to submit messages with attachements in LogBook (ELog)

This software was developed for the SIT project.  If you use all or
part of it, please give an appropriate acknowledgment.

@see LogBookWebService.py

@version $Id: LogBookGrabber_qt 12651 2016-09-22 22:59:52Z mshankar@SLAC.STANFORD.EDU $

@author Mikhail S. Dubrovin
"""

#--------------------------------
__version__ = "V2015-05-15"
#--------------------------------
#  Imports of standard modules --
#--------------------------------
import os
import logging
import pwd
import tempfile
import sys
import re
import platform
import getpass
import pwd
from copy import deepcopy
from time import time, localtime, strftime, sleep

from datetime import datetime, timedelta

from PyQt5 import QtGui, QtCore, QtWidgets

from LogBookClient.LogBookWebService import LogBookWebService, submit_msg_to_elog
from LogBookClient.TagCompleter import TagCompleter
from LogBookClient.MsgTextEdit import MsgTextEdit

__author__ = "Mikhail S. Dubrovin"


plogger = logging.getLogger(__name__)

class Logger :
    """Is intended as a log-book keeper.
    """
    name = 'Logger'

    def __init__ ( self, fname=None, level='info' ) :
        """Constructor.
        @param fname  the file name for output log file
        """
        self.levels = ['debug','info','warning','error','crytical']
        self.setLevel(level)
        self.selectionIsOn = True # It is used to get total log content

        self.log = []
        self.startLog(fname)


    def setLevel(self, level):
        """Sets the threshold level of messages for record selection algorithm"""
        self.level_thr     = level
        self.level_thr_ind = self.levels.index(level)


    def getListOfLevels(self):
        return self.levels


    def getLevel(self):
        return self.level_thr


    def getLogFileName(self):
        return self.fname


    def getLogTotalFileName(self):
        return self.fname_total


    def getStrStartTime(self):
        return self.str_start_time


    def debug   ( self, msg, name=None ) : self._message(msg, 0, name)

    def info    ( self, msg, name=None ) : self._message(msg, 1, name)

    def warning ( self, msg, name=None ) : self._message(msg, 2, name)

    def error   ( self, msg, name=None ) : self._message(msg, 3, name)

    def crytical( self, msg, name=None ) : self._message(msg, 4, name)

    def _message ( self, msg, index, name=None ) :
        """Store input message the 2D tuple of records, send request to append GUI.
        """
        tstamp    = self.timeStamp()
        level     = self.levels[index]
        rec       = [tstamp, level, index, name, msg]
        self.log.append(rec)

        if self.recordIsSelected( rec ) :
            str_msg = self.stringForRecord(rec)
            self.appendGUILog(str_msg)
            #print str_msg


    def recordIsSelected( self, rec ):
        """Apply selection algorithms for each record:
           returns True if the record is passed,
                   False - the record is discarded from selected log content.
        """
        if not self.selectionIsOn       : return True
        if rec[2] < self.level_thr_ind  : return False
        else                            : return True


    def stringForRecord( self, rec ):
        """Returns the strind presentation of the log record, which intrinsically is a tuple."""
        tstamp, level, index, name, msg = rec
        self.msg_tot = ''
        if name is not None :
            self.msg_tot  = tstamp
            self.msg_tot += ' (' + level + ') '
            self.msg_tot += name + ': '
        else :
            self.msg_tot += ': '
        self.msg_tot += msg
        return self.msg_tot


    def appendGUILog(self, msg='') :
        """Append message in GUI, if it is available"""
        try    : self.guilogger.appendGUILog(msg)
        except : pass


    def setGUILogger(self, guilogger) :
        """Receives the reference to GUI"""
        self.guilogger = guilogger


    def timeStamp( self, fmt='%Y-%m-%d %H:%M:%S' ) : # '%Y-%m-%d %H:%M:%S %Z'
        return strftime(fmt, localtime())


    def startLog(self, fname=None) :
        """Logger initialization at start"""
        self.str_start_time = self.timeStamp( fmt='%Y-%m-%d-%H:%M:%S' )
        if  fname == None :
            self.fname       = self.str_start_time + '-log.txt'
            self.fname_total = self.str_start_time + '-log-total.txt'
        else :
            self.fname       = fname
            self.fname_total = self.fname + '-total'

        self.info ('Start session log file: ' + self.fname,       self.name)
        self.debug('Total log file name: '    + self.fname_total, self.name)


    def getLogContent(self):
        """Return the text content of the selected log records"""
        self.log_txt = ''
        for rec in self.log :
            if self.recordIsSelected( rec ) :
                self.log_txt += self.stringForRecord(rec) + '\n'
        return  self.log_txt


    def getLogContentTotal(self):
        """Return the text content of all log records"""
        self.selectionIsOn = False
        log_txt = self.getLogContent()
        self.selectionIsOn = True
        return log_txt


    def saveLogInFile(self, fname=None):
        """Save content of the selected log records in the text file"""
        if fname == None : fname_log = self.fname
        else             : fname_log = fname
        self._saveTextInFile(self.getLogContent(), fname_log)


    def saveLogTotalInFile(self, fname=None):
        """Save content of all log records in the text file"""
        if fname == None : fname_log = self.fname_total
        else             : fname_log = fname
        self._saveTextInFile(self.getLogContentTotal(), fname_log)


    def _saveTextInFile(self, text, fname='log.txt'):
        self.debug('saveTextInFile: ' + fname, self.name)
        f=open(fname,'w')
        f.write(text)
        f.close()

#-----------------------------

logger = Logger (fname=None)

#-----------------------------

def test_Logger() :

    #logger.setLevel('debug')
    logger.setLevel('warning')

    logger.debug   ('This is a test message 1', __name__)
    logger.info    ('This is a test message 2', __name__)
    logger.warning ('This is a test message 3', __name__)
    logger.error   ('This is a test message 4', __name__)
    logger.crytical('This is a test message 5', __name__)
    logger.crytical('This is a test message 6')

    #logger.saveLogInFile()
    #logger.saveLogTotalInFile()

    print('getLogContent():\n',      logger.getLogContent())
    print('getLogContentTotal():\n', logger.getLogContentTotal())

#-----------------------------
#-----------------------------
#-----------------------------
#-----------------------------
#------ GlobalUtils.py -------
#-----------------------------

def stringOrNone(value):
    if value == None : return 'None'
    else             : return str(value)

def intOrNone(value):
    if value == None : return None
    else             : return int(value)

#-----------------------------

def get_save_fname_through_dialog_box(parent, path0, dial_title, filter='*.txt'):

    path = str( QtWidgets.QFileDialog.getSaveFileName(parent,
                                                  caption   = dial_title,
                                                  directory = path0,
                                                  filter    = filter
                                                  ) )
    if path == '' :
        logger.debug('Saving is cancelled.', 'get_save_fname_through_dialog_box')
        #print 'Saving is cancelled.'
        return None
    logger.info('Output file: ' + path, 'get_save_fname_through_dialog_box')
    #print 'Output file: ' + path
    return path

#-----------------------------

def get_open_fname_through_dialog_box(parent, path0, dial_title, filter='*.txt'):

    path = str( QtWidgets.QFileDialog.getOpenFileName(parent, dial_title, path0, filter=filter)[0] )
    dname, fname = os.path.split(path)
    if dname == '' or fname == '' :
        logger.info('Input directiry name or file name is empty... keep file path unchanged...')
        #print 'Input directiry name or file name is empty... keep file path unchanged...'
        return None
    logger.info('Input file: ' + path, 'get_open_fname_through_dialog_box')
    #print 'Input file: ' + path
    return path

#-----------------------------

def confirm_dialog_box(parent=None, text='Please confirm that you aware!', title='Please acknowledge') :
        """Pop-up MODAL box for confirmation"""

        mesbox = QtWidgets.QMessageBox(parent, windowTitle=title,
                                           text=text,
                                           standardButtons=QtWidgets.QMessageBox.Ok)
               #standardButtons=QtWidgets.QMessageBox.Save | QtWidgets.QMessageBox.Discard | QtWidgets.QMessageBox.Cancel)
        #mesbox.setDefaultButton(QtWidgets.QMessageBox.Ok)
        #mesbox.setMinimumSize(400, 200)
        #style = "background-color: rgb(255, 200, 220); color: rgb(0, 0, 100);" # Pinkish
        style = "background-color: rgb(255, 255, 220); color: rgb(0, 0, 0);" # Yellowish
        mesbox.setStyleSheet (style)

        clicked = mesbox.exec_() # DISPLAYS THE QMessageBox HERE

        #if   clicked == QtWidgets.QMessageBox.Save :
        #    logger.info('Saving is requested', __name__)
        #elif clicked == QtWidgets.QMessageBox.Discard :
        #    logger.info('Discard is requested', __name__)
        #else :
        #    logger.info('Cancel is requested', __name__)
        #return clicked

        logger.info('You acknowkeged that saw the message:\n' + text, 'confirm_dialog_box')
        return

#-----------------------------

def help_dialog_box(parent=None, text='Help message goes here', title='Help') :
        """Pop-up NON-MODAL box for help etc."""

        messbox = QtWidgets.QMessageBox(parent, windowTitle=title,
                                           text=text,
                                           standardButtons=QtWidgets.QMessageBox.Close)
        messbox.setStyleSheet (cp.styleBkgd)
        messbox.setWindowModality (QtCore.Qt.NonModal)
        messbox.setModal (False)
        #clicked = messbox.exec_() # For MODAL dialog
        clicked = messbox.show()  # For NON-MODAL dialog
        logger.info('Help window is open' + text, 'help_dialog_box')
        return messbox

#-----------------------------
#-----------------------------
#-----------------------------
#-----------------------------

class Parameter :
    """Single parameters.
    #@see OtherClass ConfigParameters
    #@see OtherClass ConfigParametersForApp
    """

    dicBool = {'false':False, 'true':True}

    _name      = 'EMPTY'
    _type      = None
    _value     = None
    _value_def = None
    _index     = None

#---------------------

    def __init__ ( self, name='EMPTY', val=None, val_def=None, type='str', index=None) :
        """Constructor.
        @param name    parameter name
        @param val     parameter value
        @param val_def parameter default value
        @param type    parameter type, implemented types: 'str', 'int', 'long', 'float', 'bool'
        @param index   parameter index the list
        """
        self.setParameter ( name, val, val_def, type, index )

#---------------------

    def setParameter ( self, name='EMPTY', val=None, val_def=None, type='str', index=None ) :
        self._value_def = val_def
        self._name      = name
        self._type      = type
        self._index     = index
        self.setValue ( val )

#---------------------

    def setValue ( self, val=None ) :
        if val == None :
            self._value = self._value_def
        else :
            if   self._type == 'str' :
                self._value = str( val )

            elif self._type == 'int' :
                self._value = int( val )

            elif self._type == 'long' :
                self._value = int( val )

            elif self._type == 'float' :
                self._value = float( val )

            elif self._type == 'bool' :
                self._value = bool( val )
            else :
                self._value = val

#---------------------

    def setDefaultValue ( self ) :
        self._value = self._value_def

#---------------------

    def setDefault (self) :
        self._value = self._value_def

#---------------------

    def setValueFromString ( self, str_val ) :
        """Set parameter value fron string based on its declared type: 'str', 'int', 'long', 'float', 'bool' """

        if str_val.lower() == 'none' :
            self._value = self._value_def

        if self._type == 'str' :
            self._value = str( str_val )

        elif self._type == 'int' :
            self._value = int( str_val )

        elif self._type == 'long' :
            self._value = int( str_val )

        elif self._type == 'float' :
            self._value = float( str_val )

        elif self._type == 'bool' :
            self._value = self.dicBool[str_val.lower()]

        else :
            msg = 'Parameter.setValueForType: Requested parameter type ' + type + ' is not supported\n'
            msg+= 'WARNING! The parameter value is left unchanged...\n'
            logger.warning(msg)
            #print(msg)

#---------------------

    def setType ( self, type='str' ) :
        self._type = type

    def setName ( self, name='EMPTY' ) :
        self._name = name

    def value ( self ) :
        return self._value

    def value_def ( self ) :
        return self._value_def

    def name ( self ) :
        return self._name

    def type ( self ) :
        return self._type

    def index( self ) :
        return self._index

#---------------------

    def strParInfo( self ) :
        s = 'Par: %s %s %s %s' % ( self.name().ljust(32), str(self.value()).ljust(32), self.type().ljust(8), str(self.index()).ljust(8) )
        return s

#---------------------

    def printParameter( self ) :
        s = self.strParInfo()
        logger.info( s )
        #print s

#-----------------------------
#-----------------------------
#-----------------------------
#-----------------------------

class ConfigParameters :
    """Is intended as a storage for configuration parameters.
    #@see OtherClass ConfigParametersCorana
    """

    name = 'ConfigParameters'

    dict_pars  = {} # Dictionary for all configuration parameters, containing pairs {<parameter-name>:<parameter-object>, ... }
    dict_lists = {} # Dictionary for declared lists of configuration parameters:    {<list-name>:<list-of-parameters>, ...}

    def __init__ ( self, fname=None ) :
        """Constructor.
        @param fname  the file name with configuration parameters, if not specified then it will be set to the default value at declaration.
        """

        self.fname_cp = 'confpars.txt'

#---------------------------------------

    def declareParameter( self, name='EMPTY', val=None, val_def=None, type='str', index=None ) :
        par = Parameter( name, val, val_def, type, index )
        #self.dict_pars[name] = par
        self.dict_pars.update( {name:par} )
        return par

#---------------------------------------

    def declareListOfPars( self, list_name='EMPTY_LIST', list_val_def_type=None ) :
        list_of_pars = []

        if list_val_def_type == None : return None

        for index,rec in enumerate(list_val_def_type) :
            name = list_name + ':' + str(index)
            val, val_def, type = rec

            #par = self.declareParameter( name, val, val_def, type, index )
            par = Parameter( name, val, val_def, type, index )
            list_of_pars.append(par)
            self.dict_pars.update( {name:par} )

        self.dict_lists.update( {list_name:list_of_pars} )

        return list_of_pars

#---------------------------------------

    def getListOfPars( self, name ) :
        return self.dict_lists[name]

#---------------------------------------

    def printListOfPars( self, name ) :
        list_of_pars = self.getListOfPars(name)

        print('Parameters for list:', name)
        for par in list_of_pars :
            par.printParameter()

#---------------------------------------

    def printParameters( self ) :
        msg = 'printParameters - Number of declared parameters in the dict: %d' % len(self.dict_pars)
        logger.info(msg, self.name)
        #print msg

        for par in list(self.dict_pars.values()) :
            s = par.strParInfo()
            logger.info( s )
            #print s

#---------------------------------------

    def setDefaultValues( self ) :
        for par in list(self.dict_pars.values()) :
            par.setDefaultValue()

#---------------------------------------

    def setParsFileName(self, fname=None) :
        if fname == None :
            self.fname = self.fname_cp
        else :
            self.fname = fname

#---------------------------------------

    def saveParametersInFile ( self, fname=None ) :
        self.setParsFileName(fname)
        logger.info('Save configuration parameters in file: ' + self.fname, self.name)
        f=open(self.fname,'w')
        for par in list(self.dict_pars.values()) :
            v = par.value()
            s = '%s %s\n' % ( par.name().ljust(32), str(v) )
            f.write( s )
        f.close()

#---------------------------------------

    def setParameterValueByName ( self, name, str_val ) :

        if not ( name in list(self.dict_pars.keys()) ) :
            msg  = 'The parameter name ' + name + ' is unknown in the dictionary.\n'
            msg += 'WARNING! Parameter needs to be declared first. Skip this parameter initialization.\n'
            logger.warning(msg)
            #print msg
            return

        self.dict_pars[name].setValueFromString(str_val)

#---------------------------------------

    def readParametersFromFile ( self, fname=None ) :
        self.setParsFileName(fname)
        msg = 'Read configuration parameters from file: ' + self.fname
        logger.info(msg, self.name)
        #print msg

        if not os.path.exists(self.fname) :
            msg = 'The file ' + self.fname + ' is not found, use default parameters.'
            logger.warning(msg, self.name)
            #print msg
            return

        f=open(self.fname,'r')
        for line in f :
            if len(line) == 1 : continue # line is empty
            fields = line.rstrip('\n').split(' ',1)
            self.setParameterValueByName ( name=fields[0], str_val=fields[1].strip(' ') )
        f.close()

#---------------------------------------

def usage() :
    msg  = 'Use command: ' + sys.argv[0] + ' [<configuration-file-name>]\n'
    msg += 'with a single or without arguments.'
    msg = '\n' + 51*'-' + '\n' + msg + '\n' + 51*'-'
    logger.warning(msg, self.name)
    #print msg

#---------------------------------------

def getConfigFileFromInput() :
    """DO NOT PARSE INPUT PARAMETERS IN THIS APPLICATION
    This is interfere with other applications which really need to use input pars,
    for example maskeditor...
    """

    return None

    msg = 'Input pars sys.argv: '
    for par in sys.argv :  msg += par
    logger.debug(msg, self.name)
    #print msg

    if len(sys.argv) > 2 :
        usage()
        msg  = 'Too many arguments ...\n'
        msg += 'EXIT application ...\n'
        sys.exit (msg)

    elif len(sys.argv) == 1 :
        return None

    else :
        path = sys.argv[1]
        if os.path.exists(path) :
            return path
        else :
            usage()
            msg  = 'Requested configuration file "' + path + '" does not exist.\n'
            msg += 'EXIT application ...\n'
            sys.exit (msg)


#---------------------------------------

# confpars = ConfigParameters () # is moved to subclass like ConfigParametersCorAna

#---------------------------------------

#-----------------------------
#-----------------------------
#-----------------------------
#-----------------------------

class ConfigParametersForApp ( ConfigParameters ) :
    """Is intended as a storage for configuration parameters for CorAna project.
    #@see BaseClass ConfigParameters
    #@see OtherClass Parameters
    """
    name = 'ConfigParametersForApp'

    list_pars = []

    def __init__ ( self, fname=None ) :
        """Constructor.
        @param fname  the file name with configuration parameters, if not specified then it will be set to the default value at declaration.
        """
        ConfigParameters.__init__(self)
        self.fname_cp = 'confpars-grabber.txt' # Re-define default config file name

        self.declareAllParameters()
        self.readParametersFromFile (fname)
        self.initRunTimeParameters()
        self.defineStyles()

    def initRunTimeParameters( self ) :
        self.iconsAreLoaded  = False
        #self.char_expand = u' \u25BE' # down-head triangle
        self.guilogger = None
        self.guihelp   = None

#-----------------------------

    def loadIcons(self) :

        if self.iconsAreLoaded : return

        self.iconsAreLoaded = True

        #path = './icons/'
        path = "%s/icons/" % os.path.dirname(sys.argv[0])

        logger.info('Load icons from directory: '+path, self.name)

        self.icon_contents      = QtGui.QIcon(path + 'contents.png'      )
        self.icon_mail_forward  = QtGui.QIcon(path + 'mail-forward.png'  )
        self.icon_button_ok     = QtGui.QIcon(path + 'button_ok.png'     )
        self.icon_button_cancel = QtGui.QIcon(path + 'button_cancel.png' )
        self.icon_exit          = QtGui.QIcon(path + 'exit.png'          )
        self.icon_home          = QtGui.QIcon(path + 'home.png'          )
        self.icon_redo          = QtGui.QIcon(path + 'redo.png'          )
        self.icon_undo          = QtGui.QIcon(path + 'undo.png'          )
        self.icon_reload        = QtGui.QIcon(path + 'reload.png'        )
        self.icon_save          = QtGui.QIcon(path + 'save.png'          )
        self.icon_save_cfg      = QtGui.QIcon(path + 'fileexport.png'    )
        self.icon_edit          = QtGui.QIcon(path + 'edit.png'          )
        self.icon_browser       = QtGui.QIcon(path + 'fileopen.png'      )
        self.icon_monitor       = QtGui.QIcon(path + 'icon-monitor.png'  )
        self.icon_unknown       = QtGui.QIcon(path + 'icon-unknown.png'  )
        self.icon_logviewer     = QtGui.QIcon(path + 'logviewer.png'     )
        self.icon_lock          = QtGui.QIcon(path + 'locked-icon.png'   )
        self.icon_unlock        = QtGui.QIcon(path + 'unlocked-icon.png' )

        self.icon_logger        = self.icon_edit
        self.icon_help          = self.icon_unknown
        self.icon_reset         = self.icon_reload


#-----------------------------


    def declareAllParameters( self ) :
        # Possible typs for declaration : 'str', 'int', 'long', 'float', 'bool'

        # GUILogger.py
        self.log_level      = self.declareParameter( name='LOG_LEVEL_OF_MSGS',  val_def='info',         type='str' )
        self.log_file       = self.declareParameter( name='LOG_FILE_FOR_LEVEL', val_def='./log_for_level.txt',       type='str' )
        #self.log_file_total = self.declareParameter( name='LOG_FILE_TOTAL',     val_def='./log_total.txt',           type='str' )

        # GUIGrabSubmitELog.py
        #self.cbx_more_options    = self.declareParameter( name='CBX_SHOW_MORE_OPTIONS',   val_def=False,             type='bool' )
        self.img_infname         = self.declareParameter( name='IMG_INPUT_FNAME',  val_def='./img-1.ppm',            type='str' )
        self.img_oufname         = self.declareParameter( name='IMG_OUTPUT_FNAME', val_def='./img-1.ppm',            type='str' )

        self.elog_post_tag       = self.declareParameter( name='ELOG_POST_TAG',           val_def='SCREENSHOT',      type='str' )
        #self.elog_post_ins       = self.declareParameter( name='ELOG_POST_INSTRUMENT',    val_def='AMO',             type='str' )
        #self.elog_post_exp       = self.declareParameter( name='ELOG_POST_EXPERIMENT',    val_def='amodaq14',        type='str' )
        #self.elog_post_in2       = self.declareParameter( name='ELOG_POST_INSTRUMENT_2',  val_def='OPS',             type='str' )
        #self.elog_post_ex2       = self.declareParameter( name='ELOG_POST_EXPERIMENT_2',  val_def='CXI Instrument',  type='str' )
        #self.elog_post_run       = self.declareParameter( name='ELOG_POST_RUN',           val_def='',                type='str' )
        #self.elog_post_res       = self.declareParameter( name='ELOG_POST_RESPONCE',      val_def='',                type='str' )
        #self.elog_post_msg       = self.declareParameter( name='ELOG_POST_MESSAGE',       val_def='',                type='str' )
        #self.elog_post_usr       = self.declareParameter( name='ELOG_POST_USER_NAME',     val_def='Unknown',         type='str' )
        #self.elog_post_sta       = self.declareParameter( name='ELOG_POST_STATION',       val_def='',                type='str' )
        #self.elog_post_url       = self.declareParameter( name='ELOG_POST_URL',           val_def='',                type='str' )
        #self.elog_post_cmd       = self.declareParameter( name='ELOG_POST_CHILD_COMMAND', val_def='',                type='str' )

#-----------------------------

    def defineStyles( self ) :
        self.styleYellowish = "background-color: rgb(255, 255, 220); color: rgb(0, 0, 0);" # Yellowish
        self.stylePink      = "background-color: rgb(255, 200, 220); color: rgb(0, 0, 0);" # Pinkish
        self.styleYellowBkg = "background-color: rgb(255, 255, 120); color: rgb(0, 0, 0);" # Pinkish
        self.styleGreenMy   = "background-color: rgb(150, 250, 230); color: rgb(0, 0, 0);" # My
        self.styleGray      = "background-color: rgb(230, 240, 230); color: rgb(0, 0, 0);" # Gray
        self.styleGreenish  = "background-color: rgb(100, 255, 200); color: rgb(0, 0, 0);" # Greenish
        self.styleGreenPure = "background-color: rgb(150, 255, 150); color: rgb(0, 0, 0);" # Green
        self.styleBluish    = "background-color: rgb(200, 200, 255); color: rgb(0, 0, 0);" # Bluish
        self.styleWhite     = "background-color: rgb(255, 255, 255); color: rgb(0, 0, 0);"
        self.styleRedBkgd   = "background-color: rgb(255,   0,   0); color: rgb(0, 0, 0);" # Red background
        self.styleTransp    = "background-color: rgb(255,   0,   0, 100);"
        self.styleDefault   = "background-color: rgb(239, 235, 231, 255); color: rgb(0, 0, 0);" # Gray bkgd
        #self.styleTitle  = "color: rgb(150, 160, 100);"
        self.styleBlue   = "color: rgb(100, 0, 150);"
        self.styleBuriy  = "color: rgb(150, 100, 50);"
        self.styleRed    = "color: rgb(255, 0, 0);"
        self.styleGreen  = "color: rgb(0, 150, 0);"
        self.styleYellow = "color: rgb(0, 150, 150);"

        #self.styleBkgd         = self.styleGreenMy # styleYellowish
        self.styleBkgd         = self.styleDefault
        self.styleTitle        = self.styleBuriy
        self.styleLabel        = self.styleBlue
        self.styleEdit         = self.styleWhite
        self.styleEditInfo     = self.styleBkgd # self.styleGreenish
        self.styleEditBad      = self.styleRedBkgd
        self.styleButton       = self.styleGray
        self.styleButtonOn     = self.styleBluish
        self.styleButtonClose  = self.stylePink
        self.styleButtonWarning= self.styleYellowBkg
        self.styleButtonGood   = self.styleGreenPure
        self.styleButtonBad    = self.stylePink
        self.styleBox          = self.styleGray
        self.styleCBox         = self.styleYellowish
        self.styleStatusGood   = self.styleGreen
        self.styleStatusWarning= self.styleYellow
        self.styleStatusAlarm  = self.styleRed
        self.styleTitleBold    = self.styleTitle + 'font-size: 18pt; font-family: Courier; font-weight: bold;'
        self.styleWhiteFixed   = self.styleWhite + 'font-family: Fixed;'

        self.colorEditInfo     = QtGui.QColor(100, 255, 200)
        self.colorEditBad      = QtGui.QColor(255,   0,   0)
        self.colorEdit         = QtGui.QColor('white')

    def printParsDirectly( self ) :
        logger.info('Direct use of parameter:' + self.fname_ped.name() + ' ' + self.fname_ped.value(), self.name )
        logger.info('Direct use of parameter:' + self.fname_dat.name() + ' ' + self.fname_dat.value(), self.name )

#-----------------------------

confpars = ConfigParametersForApp ()
cp = confpars

#-----------------------------

def test_ConfigParametersForApp() :
    confpars.printParameters()
    #confpars.printParsDirectly()
    confpars.saveParametersInFile()

#-----------------------------
#-----------------------------
#-----------------------------
#-----------------------------

class GUILogger ( QtWidgets.QWidget ) :
    """GUI for Logger"""

    name = 'GUILogger'

    def __init__ ( self, parent=None ) :

        QtWidgets.QWidget.__init__(self, parent)

        self.setGeometry(200, 400, 900, 500)
        self.setWindowTitle('GUI Logger')
        #self.setWindowIcon(cp.icon_logger)

        self.setFrame()

        self.box_txt    = QtWidgets.QTextEdit()

        #self.tit_title  = QtWidgets.QLabel('Logger')
        self.tit_status = QtWidgets.QLabel('Status:')
        self.tit_level  = QtWidgets.QLabel('Verbosity level:')
        self.but_close  = QtWidgets.QPushButton('&Close')
        self.but_save   = QtWidgets.QPushButton('&Save log-file')

        self.list_of_levels = logger.getListOfLevels()
        self.box_level      = QtWidgets.QComboBox( self )
        self.box_level.addItems(self.list_of_levels)
        self.box_level.setCurrentIndex( self.list_of_levels.index(cp.log_level.value()) )

        self.hboxM = QtWidgets.QHBoxLayout()
        self.hboxM.addWidget( self.box_txt )

        self.hboxB = QtWidgets.QHBoxLayout()
        self.hboxB.addWidget(self.tit_status)
        self.hboxB.addStretch(4)
        self.hboxB.addWidget(self.tit_level)
        self.hboxB.addWidget(self.box_level)
        self.hboxB.addStretch(1)
        self.hboxB.addWidget(self.but_save)
        self.hboxB.addWidget(self.but_close)

        self.vbox  = QtWidgets.QVBoxLayout()
        #self.vbox.addWidget(self.tit_title)
        self.vbox.addLayout(self.hboxM)
        self.vbox.addLayout(self.hboxB)
        self.setLayout(self.vbox)

        self.connect( self.but_close, QtCore.SIGNAL('clicked()'), self.onClose )
        self.connect( self.but_save,  QtCore.SIGNAL('clicked()'), self.onSave  )
        self.connect( self.box_level, QtCore.SIGNAL('currentIndexChanged(int)'), self.onBox  )

        self.startGUILog()

        self.showToolTips()
        self.setStyle()

    #-------------------
    #  Public methods --
    #-------------------

    def showToolTips(self):
        #self           .setToolTip('This GUI is for browsing log messages')
        self.box_txt    .setToolTip('Window for log messages')
        self.but_close  .setToolTip('Close this window')
        self.but_save   .setToolTip('Save current content of the GUI Logger\nin work directory file: '+os.path.basename(self.fname_log))
        self.tit_status .setToolTip('The file name, where this log \nwill be saved at the end of session')
        self.box_level  .setToolTip('Click on this button and \nselect the level of messages \nwhich will be displayed')


    def setFrame(self):
        self.frame = QtWidgets.QFrame(self)
        self.frame.setFrameStyle( QtWidgets.QFrame.Box | QtWidgets.QFrame.Sunken ) #Box, Panel | Sunken, Raised
        self.frame.setLineWidth(0)
        self.frame.setMidLineWidth(1)
        self.frame.setGeometry(self.rect())
        #self.frame.setVisible(False)


    def setStyle(self):
        self.           setStyleSheet (cp.styleBkgd)
        #self.tit_title.setStyleSheet (cp.styleTitleBold)
        self.tit_status.setStyleSheet (cp.styleTitle)
        self.tit_level .setStyleSheet (cp.styleTitle)
        self.but_close .setStyleSheet (cp.styleButton)
        self.but_save  .setStyleSheet (cp.styleButton)
        self.box_level .setStyleSheet (cp.styleButton)
        self.box_txt   .setReadOnly(True)
        self.box_txt   .setStyleSheet (cp.styleWhiteFixed)
        #self.box_txt   .ensureCursorVisible()
        #self.tit_title.setAlignment(QtCore.Qt.AlignCenter)
        #self.titTitle.setBold()


    def setParent(self,parent) :
        self.parent = parent


    def resizeEvent(self, e):
        #logger.debug('resizeEvent', self.name)
        self.frame.setGeometry(self.rect())


    def moveEvent(self, e):
        #logger.debug('moveEvent', self.name)
        #cp.posGUIMain = (self.pos().x(),self.pos().y())
        pass


    def closeEvent(self, event):
        logger.debug('closeEvent', self.name)
        #self.saveLogTotalInFile() # It will be saved at closing of GUIMain

        #try    : del cp.guilogger # GUILogger
        #except : pass

        #if cp.guilogger!=None :
        #    del cp.guilogger
        #    cp.guilogger = None


    def onClose(self):
        logger.debug('onClose', self.name)
        self.close()


    def onSave(self):
        logger.debug('onSave:', self.name)
        self.saveLogInFile()


    def onBox(self):
        level_selected = self.box_level.currentText()
        cp.log_level.setValue( level_selected )
        logger.info('onBox - selected ' + self.tit_level.text() + ' ' + cp.log_level.value(), self.name)
        logger.setLevel(cp.log_level.value())
        self.box_txt.setText( logger.getLogContent() )


    def saveLogInFile(self):
        logger.info('saveLogInFile ' + self.fname_log, self.name)
        path = str( QtWidgets.QFileDialog.getSaveFileName(self,
                                                      caption   = 'Select the file to save log',
                                                      directory = self.fname_log,
                                                      filter    = '*.txt'
                                                      ) )
        if path == '' :
            logger.debug('Saving is cancelled.', self.name)
            return
        logger.info('Output file: ' + path, self.name)
        logger.saveLogInFile(path)
        self.fname_log = path
        cp.log_file.setValue(path)


    def saveLogTotalInFile(self):
        logger.info('saveLogTotalInFile' + self.fname_log_total, self.name)
        logger.saveLogTotalInFile(self.fname_log_total)


    def getConfirmation(self):
        """Pop-up box for confirmation"""
        msg = QtWidgets.QMessageBox(self, windowTitle='Confirm closing!',
            text='You are about to close GUI Logger...\nIf the log-file is not saved it will be lost.',
            standardButtons=QtWidgets.QMessageBox.Save | QtWidgets.QMessageBox.Discard | QtWidgets.QMessageBox.Cancel)
        msg.setDefaultButton(msg.Save)

        clicked = msg.exec_()

        if   clicked == QtWidgets.QMessageBox.Save :
            logger.info('Saving is requested', self.name)
        elif clicked == QtWidgets.QMessageBox.Discard :
            logger.info('Discard is requested', self.name)
        else :
            logger.info('Cancel is requested', self.name)
        return clicked


    def onShow(self):
        logger.info('onShow - is not implemented yet...', self.name)


    def startGUILog(self) :
        self.fname_log       = cp.log_file.value()
        #self.fname_log_total = cp.log_file_total.value()
        self.setStatus(0, 'Log-file: ' + os.path.basename(self.fname_log))

        logger.setLevel(cp.log_level.value())
        self.box_txt.setText(logger.getLogContent())

        logger.setGUILogger(self)
        logger.debug('GUILogger is open', self.name)
        self.box_txt.moveCursor(QtGui.QTextCursor.End)


    def appendGUILog(self, msg='...'):
        self.box_txt.append(msg)
        self.scrollDown()


    def scrollDown(self):
        #print 'scrollDown'
        #scrol_bar_v = self.box_txt.verticalScrollBar() # QScrollBar
        #scrol_bar_v.setValue(scrol_bar_v.maximum())
        self.box_txt.moveCursor(QtGui.QTextCursor.End)
        self.box_txt.repaint()
        #self.raise_()
        #self.box_txt.update()


    def setStatus(self, status_index=0, msg=''):
        list_of_states = ['Good','Warning','Alarm']
        if status_index == 0 : self.tit_status.setStyleSheet(cp.styleStatusGood)
        if status_index == 1 : self.tit_status.setStyleSheet(cp.styleStatusWarning)
        if status_index == 2 : self.tit_status.setStyleSheet(cp.styleStatusAlarm)

        #self.tit_status.setText('Status: ' + list_of_states[status_index] + msg)
        self.tit_status.setText(msg)

#-----------------------------

def test_GUILogger() :
    app = QtGui.QApplication(sys.argv)
    widget = GUILogger ()
    widget.show()
    app.exec_()


class GUIImage ( QtWidgets.QLabel ) :
#class GUIImage ( QtGui.QGraphicsView ) :
    """Main GUI of the Image Grabber for ELog
    @see BaseClass
    @see OtherClass
    """

    name = 'GUIImage'

    def __init__ (self, parent=None, app=None) :

        self.myapp = app
        QtWidgets.QLabel.__init__(self, parent)
        #QtGui.QGraphicsView.__init__(self)

        self.setGeometry(200, 100, 100, 30)
        self.setWindowTitle('Image For Grabber')
        self.palette = QtGui.QPalette()
        self.resetColorIsSet = False

        #self.grview = QtGui.QGraphicsView()
        #self.setCentralWidget(self.grview)
        #self.setWidget(self.grview)

        self.setFrame()

        self.poi1  = QtCore.QPoint(0,0)
        self.poi2  = QtCore.QPoint(0,0)
        self.rect1 = QtCore.QRect()
        self.rect2 = QtCore.QRect()

        self.pen1 = QtGui.QPen(QtCore.Qt.black)
        self.pen2 = QtGui.QPen(QtCore.Qt.white)
        self.pen1.setStyle(QtCore.Qt.DashLine)
        self.pen2.setStyle(QtCore.Qt.DashLine)
        self.pen1.setWidthF(1)
        self.pen2.setWidthF(1)


        self.o_pixmap_list = [] # list of old pixmap
        self.r_pixmap = None # raw pixmap
        self.s_pixmap = None # scailed for image pixmap

        self.qp = QtGui.QPainter()
        #self.pixmap_item = None
        self.counter = 0
        #self.vbox = QtWidgets.QVBoxLayout()
        #self.vbox.addWidget(self.grview)
        ##self.vbox.addStretch(1)
        ##self.vbox.addWidget(self.wbutbar)
        #self.setLayout(self.vbox)

        #self.connect(self.butFiles      ,  QtCore.SIGNAL('clicked()'), self.onFiles   )

        self.showToolTips()
        self.setStyle()

        self.isInZoomMode = False
        self.postHiQualityImages = False


        #self.grabImage()
        #self.show()
        #cp.guiimage = self

    #-------------------
    # Private methods --
    #-------------------

    def grabImage(self):
        #self.setMinimumSize(150, 150)
        #fname = tempfile.NamedTemporaryFile(mode='r+b',suffix='.ppm')
        fname = tempfile.NamedTemporaryFile(mode='r+b',suffix='.png')
        #print fname.name
        #logger.info('Use temporary file: %s' % (fname.name), self.name)
        if( 0 == os.system('import -trim -frame -border %s' % (fname.name))) :
            self.r_pixmap = QtGui.QPixmap(QtGui.QImage(fname.name)) # , format='???'))
            self.setPixmapForImage()

    def grabFullScreen(self):
        #self.setMinimumSize(150, 150)
        #fname = tempfile.NamedTemporaryFile(mode='r+b',suffix='.ppm')
        fname = tempfile.NamedTemporaryFile(mode='r+b',suffix='.png')
        #print fname.name
        #logger.info('Use temporary file: %s' % (fname.name), self.name)
        if( 0 == os.system('import -trim -frame -border -window root %s' % (fname.name))) :
            self.r_pixmap = QtGui.QPixmap(QtGui.QImage(fname.name)) # , format='???'))
            self.setPixmapForImage()

    def grabEntireWindow(self):
        self.r_pixmap = QtGui.QPixmap.grabWindow(QtGui.QApplication.desktop().winId())
        self.setPixmapForImage()

    def setHiQualityImage(self, postHighQualityImages):
        self.postHiQualityImages = postHighQualityImages

    def resetImage(self):
        #self.setMinimumSize(150, 10)
        self.r_pixmap = None
        self.setPixmapForImage()


    def loadImageFromFile(self, fname) : #Read formats: bmp, jpg, jpeg, png, ppm, xbm, xpm + gif, pbm, pgm,
        self.r_pixmap = QtGui.QPixmap(QtGui.QImage(fname))
        self.setPixmapForImage()


    def setPixmapForImage(self):
        if self.r_pixmap == None :
            self.s_pixmap = None
            self.clear()
        else :
            #self.s_pixmap = self.r_pixmap.scaled(self.size())
            self.s_pixmap = self.r_pixmap.scaled(self.size(), QtCore.Qt.KeepAspectRatio)
            self.setPixmap(self.s_pixmap)
            self.setAlignment(QtCore.Qt.AlignTop | QtCore.Qt.AlignLeft)
            self.setScailedMask()


    def setScailedMask(self):
        size = self.s_pixmap.size()
        #print 'Scaled pixmap size: %d x %d' % (size.width(), size.height())

        #==================================
        self.qimage_mask = QtGui.QImage(size, QtGui.QImage.Format_Mono)
        self.qimage_mask.fill(0)
        self.qbitmap_mask = QtGui.QBitmap.fromImage(self.qimage_mask)
        self.s_pixmap.setMask(self.qbitmap_mask)
        #==================================


    def saveImageInFile(self, fname='test.png'): #Write formats: bmp, jpg, jpeg, png, pbm, pgm, ppm, xbm, xpm
        if self.r_pixmap is not None :
            if self.postHiQualityImages:
                plogger.info("Saving a high quality image")
                self.r_pixmap.save(fname, format="PNG", quality=92)
            else:
                plogger.info("Saving a medium quality image")
                self.r_pixmap.save(fname, format=None)


    def showToolTips(self):
        self.setToolTip('Window for image')


    def setFrame(self):
        self.frame = QtWidgets.QFrame(self)
        self.frame.setFrameStyle( QtWidgets.QFrame.Box | QtWidgets.QFrame.Sunken ) #Box, Panel | Sunken, Raised
        self.frame.setLineWidth(0)
        self.frame.setMidLineWidth(1)
        self.frame.setGeometry(self.rect())
        #self.frame.setVisible(False)
        self.frame.setStyleSheet('background: transparent;')


    def setStyle(self):
        self               .setStyleSheet(cp.styleWhite)
        #self.titControl    .setStyleSheet(cp.styleTitle)
        #self.butFiles      .setStyleSheet(cp.styleButton)
        #self.butLogger     .setStyleSheet(cp.styleGreenish)
        #self.titControl    .setAlignment(QtCore.Qt.AlignCenter)
        #self.setMinimumWidth(600)
        #self.setMinimumHeight(300)
        #self.setMinimumSize(150, 10)
        self.setMinimumSize(150, 150)
        self.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding)
        #self.setMaximumSize(900, 900)


    def resizeEvent(self, e):
        s = self.size()
        self.frame.setGeometry(QtCore.QRect(0,0,s.width(),s.height()))
        self.setPixmapForImage()
        #self.update()
        #print 'resizeEvent'


    def moveEvent(self, e):
        #logger.debug('moveEvent',  self.name)
        #self.position = self.mapToGlobal(self.pos())
        #self.position = self.pos()
        #logger.debug('moveEvent - pos:' + str(self.position), self.name)
        pass


    def closeEvent(self, event):
        #print 'closeEvent'
        #logger.info('closeEvent', self.name)

        #if cp.res_save_log :
        #    logger.saveLogInFile     ( fnm.log_file() )
        #    logger.saveLogTotalInFile( fnm.log_file_total() )

        #try    : cp.guifiles.close()
        #except : pass
        pass

    def onExit(self):
        #logger.debug('onExit', self.name)
        self.close()

#-----------------------------

    def mouseMoveEvent(self, e):
        #print 'mouseMoveEvent: x, y = %d, %d' % (e.pos().x(), e.pos().y())
        self.poi2.setX(e.pos().x())
        self.poi2.setY(e.pos().y())

        #self.line.setLine( 0, 0, e.pos().x(), e.pos().y())
        #self.line.setP2(pos)
        #self.rect.setCoords( 5, 5, e.pos().x(), e.pos().y())
        #self.update()

    def mousePressEvent(self, e):
        if e.button() == 4 and len(self.o_pixmap_list)>0 : # Undo last zoom-in
            self.r_pixmap = self.o_pixmap_list.pop()
            self.setPixmapForImage()
        #else : self.o_pixmap_list = []

        self.poi1.setX(e.pos().x())
        self.poi1.setY(e.pos().y())
        self.poi2.setX(e.pos().x())
        self.poi2.setY(e.pos().y())
        #print 'mousePressEvent: e.x, e.y, e.button =', str(e.x()), str(e.y()), str(e.button())

        self.isInZoomMode = True
        self.update()


    def mouseReleaseEvent(self, e):
        self.poi2.setX(e.pos().x())
        self.poi2.setY(e.pos().y())
        #print 'mouseReleaseEvent: e.x, e.y, e.button =', str(e.x()), str(e.y()), str(e.button())
        self.zoomInImage()
        self.isInZoomMode = False


    def zoomInImage(self):
        if self.r_pixmap == None:
            self.resetRectPoints()
            return

        s_size = self.s_pixmap.size()
        r_size = self.r_pixmap.size()
        sw, sh = s_size.width(), s_size.height()
        rw, rh = r_size.width(), r_size.height()
        sclx, scly = float(rw)/sw, float(rh)/sh

        #print '='*50
        #print 'zoomInImage: s_size: w, h = %d, %d' % (sw, sh)
        #print 'zoomInImage: r_size: w, h = %d, %d' % (rw, rh)

        p1x, p1y = self.poi1.x(), self.poi1.y()
        p2x, p2y = self.poi2.x(), self.poi2.y()

        self.resetRectPoints()

        if p2x < 0  : p2x = 0
        if p2y < 0  : p2y = 0
        if p2x > sw : p2x = sw
        if p2y > sh : p2y = sh

        R=10
        if abs(p2x-p1x) < R : return
        if abs(p2y-p1y) < R : return

        #print 'zoomInImage: p1: x, y = %d, %d' % (p1x, p1y)
        #print 'zoomInImage: p2: x, y = %d, %d' % (p2x, p2y)

        x1, y1, x2, y2 = int(p1x*sclx), int(p1y*scly), int(p2x*sclx), int(p2y*scly)
        #print 'zoomInImage: x1, y1, x2, y2  = %d, %d, %d, %d' % (x1, y1, x2, y2)

        xmin, xmax = min(x1, x2), max(x1, x2)
        ymin, ymax = min(y1, y2), max(y1, y2)
        self.o_pixmap_list.append(self.r_pixmap)
        self.r_pixmap = self.r_pixmap.copy(xmin, ymin, xmax-xmin, ymax-ymin)
        self.setPixmapForImage()
        # return and remove the oldest list, Keeps 10 latest images only.
        if len(self.o_pixmap_list) > 10 : list = self.o_pixmap_list.pop(0)


    def resetRectPoints(self):
        self.poi1.setX(0)
        self.poi1.setY(0)
        self.poi2.setX(0)
        self.poi2.setY(0)


    def paintEvent(self, e):
        super(GUIImage,self).paintEvent(e)
        #self.counter+=1
        #print 'paintEvent: self.isInZoomMode: ', self.isInZoomMode, self.counter
        #qp = QtGui.QPainter()

        if not self.isInZoomMode : return

        qp = self.qp
        qp.begin(self)
        #self.drawPixmap(qp)
        self.drawRect(qp)
        qp.end()
        self.update()


    def setPen(self, qp):
        self.pen.setStyle(QtCore.Qt.DashLine)
        self.pen.setWidthF(1)


    def drawRect(self, qp):
        if self.r_pixmap == None:
            return

        p1x, p1y = self.poi1.x(), self.poi1.y()
        p2x, p2y = self.poi2.x(), self.poi2.y()

        R=1
        if abs(p2x-p1x) < R : return
        if abs(p2y-p1y) < R : return

        self.rect1.setCoords( p1x,   p1y,   p2x,   p2y)
        self.rect2.setCoords( p1x+1, p1y+1, p2x-1, p2y-1)
        qp.setPen  (self.pen1)
        qp.drawRect(self.rect1);
        qp.setPen  (self.pen2)
        qp.drawRect(self.rect2);


    def drawPixmap(self, qp):
        if self.r_pixmap != None:
            qp.drawPixmap(0,0,self.s_pixmap)

#-----------------------------

    #def mousePressEvent(self, event):
    #    print 'event.x, event.y, event.button =', str(event.x()), str(event.y()), str(event.button())

    #def mouseReleaseEvent(self, event):
    #    print 'event.x, event.y, event.button =', str(event.x()), str(event.y()), str(event.button())

#http://doc.qt.nokia.com/4.6/qt.html#Key-enum
    def keyPressEvent(self, event):
        #print 'event.key() = %s' % (event.key())
        if event.key() == QtCore.Qt.Key_Escape:
            #self.close()
            self.SHowIsOn = False
            pass

        if event.key() == QtCore.Qt.Key_B:
            #print 'event.key() = %s' % (QtCore.Qt.Key_B)
            pass

        if event.key() == QtCore.Qt.Key_Return:
            #print 'event.key() = Return'
            pass

        if event.key() == QtCore.Qt.Key_Home:
            #print 'event.key() = Home'
            pass

#-----------------------------
#  In case someone decides to run this module
#
def test_GUIImage():
    app = QtGui.QApplication(sys.argv)
    ex  = GUIImage()
    ex.grabEntireWindow()
    ex.show()
    app.exec_()

#-----------------------------
#-----------------------------
#-----------------------------
#-----------------------------

class LocalParameter :
    """This helper class allows to access local parameters through the reference in the list."""
    _val=None

    def __init__ ( self, val=None ) :
        self._val = val

    def setValue ( self, val ) :
        self._val = val

    def getValue (self) :
        return self._val

    def value (self) :
        return self._val

class BtnStatusCtxMgr:
    """
    Context manager to enable/disable the various status buttons while image grabbing etc
    """
    def __init__(self, mainwin, msg):
        self.mainwin = mainwin
        self.msg = msg
        self.title = self.mainwin.windowTitle()
    def __enter__(self):
        self.mainwin.but_elog.setEnabled(False)
        self.mainwin.but_elog_ins.setEnabled(False)
        self.mainwin.but_jira_issue.setEnabled(False)
        self.mainwin.setWindowTitle(self.title + " " + self.msg)
        return "CtxMgr"
    def __exit__(self, exc_type, exc_value, exc_tb):
        self.mainwin.but_elog.setEnabled(True)
        self.mainwin.but_elog_ins.setEnabled(True)
        self.mainwin.but_jira_issue.setEnabled(True)
        self.mainwin.setWindowTitle(self.title)
        if exc_value:
            plogger.exception("Exception during " + self.msg, exc_value)
            help_dialog_box(self.mainwin, text="Exception during " + self.msg + " " + str(exc_value))
        return True

#-----------------------------
#-----------------------------
#-----------------------------
#-----------------------------

class GUIGrabSubmitELog ( QtWidgets.QWidget ) :
    """GUI sets fields for ELog posting"""
    lb_resize = QtCore.pyqtSignal()

    name = 'GUIGrabSubmitELog' # for logger

    # Reserve local parameters for ALL FIELDS in GUI
    usr = LocalParameter ()
    submitter =  LocalParameter ()
    ins = LocalParameter ()
    in2 = LocalParameter ()
    exp = LocalParameter ()
    run = LocalParameter ()
    tag = LocalParameter ()
    res = LocalParameter ()
    msg = LocalParameter ()

    def __init__ ( self, parent=None, cfname=None, ifname=None, ofname=None, help_msg=None, lbws=None, lbws2=None, opts=None ) :
        QtWidgets.QWidget.__init__(self)
        self.setGeometry(50, 10, 620, 620)
        self.setWindowTitle('Grubber for ELog')
        self.setFrame()

        #---- Set all initial parameters -----------------------

        self.setConfigPars(cfname)              ### <===========

        if ifname is None : self.ifname = cp.img_infname.value()
        else              : self.ifname = ifname

        if ofname is None : self.ofname = cp.img_oufname.value()
        else              : self.ofname = ofname

        self.parent     = parent
        self.lbws       = lbws
        self.lbws2      = lbws2
        self.opts       = opts
        self.count_msgs = 0

        self.setLocalPars()            ### <==========

        if help_msg==None : self.help_msg = self.help_message()
        else              : self.help_msg = help_msg

        cp.printParameters()

        self.time_of_last_click = None
        self.time_out_double_click = 3 # sec

        if self.lbws is not None :
            self.list_of_exps = self.lbws.get_list_of_experiments()
            self.exp_ind_in_list = self.list_of_exps.index(self.exp.value()) if (self.exp.value() in self.list_of_exps) else 0

        self.tag_timeouts = [ 2, 5, 10, 20, 30]
        self.tag_timeout_index = 2

        #-------------------------------------------------------

        self.wimg = GUIImage(self)

        self.box_exp = QtWidgets.QComboBox( self )
        self.box_exp.addItems(self.list_of_exps)
        self.box_exp.setCurrentIndex(self.exp_ind_in_list)

        self.but_grab     = QtWidgets.QPushButton('&Grab')
        self.but_load     = QtWidgets.QPushButton('&Load File')
        self.but_reset    = QtWidgets.QPushButton('&Clear Msg')
        self.but_fsgrab   = QtWidgets.QPushButton('&Full screen grab')
        self.but_save     = QtWidgets.QPushButton('Save img')
        self.but_currexp  = QtWidgets.QPushButton()
        self.but_currexp.setIcon(QtGui.QIcon(os.path.abspath(os.path.join(__file__, "..", "..", "static", "refresh.svg"))))
        self.but_currexp.setObjectName("setcurexp")
        self.hi_quality = QtWidgets.QCheckBox('Hi&Q')
        self.hi_quality.setObjectName("Post a high quality image with minimal compression.")
        self.but_issue  = QtWidgets.QPushButton()
        self.but_issue.setIcon(QtGui.QIcon(os.path.abspath(os.path.join(__file__, "..", "..", "static", "bug.svg"))))
        self.but_issue.setObjectName("Log an issue")
        self.but_jira_issue  = QtWidgets.QPushButton("Submit(+ins)+J&IRA")
        self.but_jira_issue.setObjectName("&Submit (+ ins) (+ JIRA)")

        self.but_elog     = QtWidgets.QPushButton('&Submit')
        self.but_elog_ins = QtWidgets.QPushButton('&Submit (+ ins)')
        self.but_logger   = QtWidgets.QPushButton('Logger')
        self.but_help     = QtWidgets.QPushButton('&Help')
        self.but_quit     = QtWidgets.QPushButton('&Exit')

        self.lab_xpost = QtWidgets.QLabel('Cross post to:')
        self.xpost_checkboxes = []

        self.setHBox1Layout()
        self.setHBoxXPost()
        self.setHBox2Layout()

        self.lab_exp = QtWidgets.QLabel('Experiment:')
        self.lab_run = QtWidgets.QLabel('Run number:')
        self.lab_sbm = QtWidgets.QLabel('Submitter:')
        self.lab_tag = QtWidgets.QLabel('Tag:')
        self.lab_tagtimeout = QtWidgets.QLabel('Tag timeout(in mins):')
        self.lab_msg = QtWidgets.QLabel('Message:')

        self.box_tagtimeouts = QtWidgets.QComboBox( self )
        self.box_tagtimeouts.addItems([str(x) for x in self.tag_timeouts])
        self.box_tagtimeouts.setCurrentIndex(self.tag_timeout_index)

        #self.edi_exp = QtWidgets.QLineEdit( self.exp.value() )
        self.edi_run = QtWidgets.QLineEdit( self.run.value() )
        self.edi_sbm = QtWidgets.QLineEdit( self.submitter.value() )
        self.edi_tag = QtWidgets.QLineEdit( self.tag.value() )

        plogger.debug("Initializing the completer")
        self.completer = TagCompleter(self.list_of_tags())
        self.edi_msg = MsgTextEdit( self.msg.value() )
        self.edi_msg.setCompleter( self.completer )

        self.grid = QtWidgets.QGridLayout()
        self.grid.setObjectName("GridLayout1")
        self.grid_row = 0

        self.grid.addWidget(self.lab_tag,          self.grid_row, 0)
        self.grid.addWidget(self.lab_tagtimeout,   self.grid_row, 5)
        self.grid_row = self.grid_row + 1;
        self.grid.addWidget(self.edi_tag,          self.grid_row, 0, 1, 5)
        self.grid.addWidget(self.box_tagtimeouts,  self.grid_row, 5, 1, 1)
        self.grid_row = self.grid_row + 1;

        self.grid.addWidget(self.lab_msg,    self.grid_row, 0)
        self.grid_row = self.grid_row + 1;
        self.grid.addWidget(self.edi_msg,    self.grid_row, 0, 5, 6)
        self.grid_row = self.grid_row + 5;

        self.grid.addWidget(self.lab_run,     self.grid_row, 0, 1, 1)
        self.grid.addWidget(self.edi_run,     self.grid_row, 1, 1, 1)
        self.grid.addWidget(self.lab_sbm,     self.grid_row, 2, 1, 1)
        self.grid.addWidget(self.edi_sbm,     self.grid_row, 3, 1, 1)
        self.grid.addWidget(self.lab_exp,     self.grid_row, 4, 1, 1)
        self.grid.addWidget(self.box_exp,     self.grid_row, 5, 1, 1)
        self.grid.addWidget(self.but_currexp, self.grid_row, 6, 1, 1)
        self.grid_row = self.grid_row + 1;

        self.hbox1_widg = QtWidgets.QWidget(self)
        self.hbox1_widg.setLayout(self.hbox1)

        self.xposthbox_widg = QtWidgets.QWidget(self)
        self.xposthbox_widg.setLayout(self.xposthbox)

        self.vbox2 = QtWidgets.QVBoxLayout()
        self.vbox2.addLayout(self.grid)
        self.vbox2_widg = QtWidgets.QWidget(self)
        self.vbox2_widg.setLayout(self.vbox2)

        self.vbox = QtWidgets.QVBoxLayout()
        self.vbox.addWidget(self.hbox1_widg)
        self.vbox.addWidget(self.xposthbox_widg)
        self.vbox.addWidget(self.vbox2_widg)
        self.vbox.addWidget(self.wimg)
        self.vbox.addLayout(self.hbox2)

        self.setLayout(self.vbox)

        self.list_of_fields = [
            [self.lab_run, self.edi_run,  self.run],
            [self.lab_sbm, self.edi_sbm,  self.submitter],
            [self.lab_tag, self.edi_tag, self.tag]
            ]
            #[self.lab_exp, self.edi_exp, self.exp],

        for [lab, edi, par] in self.list_of_fields :
                edi.editingFinished.connect(self.onEdit)

        self.tag_timer = QtCore.QTimer()
        self.tag_timer.timeout.connect(self.tag_timer_tick)
        self.tag_timer.start(15*1000)

        self.edi_msg.textChanged.connect(self.onEditMessage)
        self.edi_msg.tagCompleted.connect(self.tagCompleted)
        self.edi_msg.firstCharacter.connect(self.firstCharacterTyped)

        self.but_grab.clicked.connect(self.on_but_grab)
        self.but_fsgrab.clicked.connect(self.on_full_screen_grab)
        self.but_reset.clicked.connect(self.on_but_reset)
        self.but_load.clicked.connect(self.on_but_load)
        self.but_save.clicked.connect(self.on_but_save)
        self.but_currexp.clicked.connect(self.on_but_currexp)
        self.but_elog.clicked.connect(self.on_but_elog)
        self.but_elog_ins.clicked.connect(self.on_but_elog_ins)
        self.but_logger.clicked.connect(self.on_but_logger)
        self.but_help.clicked.connect(self.on_but_help)
        self.but_quit.clicked.connect(self.on_but_quit)
        self.but_issue.clicked.connect(self.on_but_daqami_crashed)
        self.but_jira_issue.clicked.connect(self.on_but_jira_issue)
        self.hi_quality.stateChanged.connect(self.on_hiquality_clicked)
        #self.connect(self.but_save_cfg, QtCore.SIGNAL('clicked()'),       self.on_but_save_cfg)

        self.box_exp.currentIndexChanged.connect(self.on_box_exp)
        #self.connect(self.cbx_more,  QtCore.SIGNAL('stateChanged(int)'),        self.on_cbx_more)

        self.box_tagtimeouts.currentIndexChanged.connect(self.on_tag_timeout_change)

        #self.setIcons()

        # See if we can pick up the styles from the stylesheet
        # self.setStyle()
        # self.setFieldsReadOnlySet1()
        #self.on_cbx_more()
        self.set_but_save_visibility()

        self.setToolTips()

        self.edi_msg.setFocus()
        self.but_grab.setProperty("hintNext", True)

        self.notification('start')

        self.showImage(is_visible=False)

        self.set_but_reset()


    #-------------------
    #  Public methods --
    #-------------------

    def setConfigPars(self, cfname) :
        if cfname is None :
            return # use default config parameters
        else :
            cp.fname_cp = self.cfname = cfname # in order to save parameters at exit
            logger.info('Re-define cofiguration pars file name: '+cfname, self.name )
            if os.path.exists(cfname) :
                cp.readParametersFromFile(cfname)



    def list_of_tags(self) :
        if self.lbws is not None :
            all_tags = self.lbws.get_list_of_tags()
            _ = [ all_tags.remove(x) for x in [ "ISSUE", "ROADBLOCK" ] if x in all_tags ]
            return all_tags
        return []

    def list_of_xpost_experiments(self) :
        if self.lbws is not None :
            return self.lbws.get_xpost_experiments()
        return []


    def setLocalPars(self):
        self.usr.setValue( self.lbws.usr )
        self.submitter.setValue( self.lbws.usr )
        self.ins.setValue( self.lbws.ins )
        self.exp.setValue( self.lbws.exp )
        self.in2.setValue( self.lbws2.ins )
        self.run.setValue( '' )
        self.res.setValue( '' )
        self.msg.setValue( '' )
        self.tag.setValue( '' )


    def setExperiment(self, exp):
        if self.lbws is not None : self.lbws.set_experiment(exp)


    def setToolTips(self):

        logger.info('Set tool-tips for all fields', self.name )

        #self           .setToolTip('Grabber for ELog GUI')
        #self.edi_exp   .setToolTip('Experiment')
        self.edi_run   .setToolTip('Use it if posting for specific run\n')
        self.edi_sbm   .setToolTip('Override the author/submitter\n')
        self.edi_tag   .setToolTip('Edit message tag')
        self.edi_msg   .setToolTip('Message for posting in ELog')
        self.but_reset .setToolTip('Clear graphical window in "Attachement"')
        self.but_grab  .setToolTip('Grab image of current monitor')
        self.but_load  .setToolTip('Load image from file')
        self.but_fsgrab.setToolTip('Grab an image of the entire screen')
        self.but_save  .setToolTip('Save image in file')
        self.but_currexp.setToolTip('Update list of active expts\nand set current')
        self.but_elog  .setToolTip('Submit message with attachment to ELog')
        self.but_elog_ins.setToolTip('Submit message with attachment to the experiment ELog and the instrument ELog')
        self.but_logger.setToolTip('Open/Close logger window')
        self.but_quit  .setToolTip('Save configuration parameters in file \nand exit this application. \n"x"-just exit application.')
        self.but_help  .setToolTip('Get help message \nin the logger window')
        self.but_issue .setToolTip('<p>Log a DAQ/AMI issue in the computing log</p><p>This provides context and timing to PCDS personnel. This happens in the background and should not interfere with your current activity</p>')
        self.but_jira_issue.setToolTip('<p>In addition to making an eLog entry and posting to the instrument eLog, also log a JIRA issue</p>')
        self.hi_quality.setToolTip('Upload a high quality version of the image with minimal compression. This will increase the attachment size significantly but may preserve details.')
        #self.cbx_more  .setToolTip('Show more control buttons')

        self.box_exp   .setToolTip('Select experiment\n from menu')
        self.box_tagtimeouts.setToolTip('Set the tag timeout')


        #self.act = QtGui.QAction(self)
        #self.act.setPriority(QtGui.QAction.HighPriority)
        #self.setVisible(True)


    def setIcons(self) :
        cp.loadIcons()
        self.but_elog    .setIcon(cp.icon_mail_forward)
        self.but_elog_ins.setIcon(cp.icon_mail_forward)
        self.but_load    .setIcon(cp.icon_browser) # icon_contents)
        self.but_save    .setIcon(cp.icon_save)
        self.but_fsgrab  .setIcon(cp.icon_browser)
        self.but_grab    .setIcon(cp.icon_monitor)
        self.but_reset   .setIcon(cp.icon_reset)
        self.but_logger  .setIcon(cp.icon_contents)
        self.but_help    .setIcon(cp.icon_help)
        self.but_quit    .setIcon(cp.icon_exit)


    def setHBox1Layout(self):
        self.hbox1 = QtWidgets.QHBoxLayout()
        self.hbox1.setObjectName("HBox1")
        self.hbox1.setContentsMargins(11, 0, 0, 0)
        self.hbox1.addWidget(self.but_grab)
        self.hbox1.addWidget(self.but_load)
        self.hbox1.addWidget(self.but_reset)
        self.hbox1.addWidget(self.but_fsgrab)
        self.hbox1.addWidget(self.hi_quality)
        self.hbox1.addWidget(self.but_issue)
        self.hbox1.addWidget(self.but_jira_issue)
        self.hbox1.addStretch(1)
        self.hbox1.addWidget(self.but_elog_ins)
        self.hbox1.addWidget(self.but_elog)
        #self.setLayout(self.hbox1)

    def setHBoxXPost(self):
        self.xposthbox = QtWidgets.QHBoxLayout()
        self.xposthbox.setObjectName("XPost HBox")
        self.xposthbox.addWidget(self.lab_xpost)
        for xpostelog in self.list_of_xpost_experiments():
            ckl = QtWidgets.QLabel(xpostelog)
            ck = QtWidgets.QCheckBox("")
            self.xpost_checkboxes.append(ck)
            self.xposthbox.addWidget(ckl)
            self.xposthbox.addWidget(ck)
            ck.setProperty("elog", xpostelog)
            ck.stateChanged.connect(self.on_xpost_clicked)
            self.xposthbox.addSpacing(20)
        self.xposthbox.addStretch(1)

    def setHBox2Layout(self):
        self.hbox2 = QtWidgets.QHBoxLayout()
        self.hbox2.setObjectName("HBox2")
        self.hbox2.addWidget(self.but_help)
        self.hbox2.addWidget(self.but_logger)
        self.hbox2.addWidget(self.but_save)
        #self.hbox2.addWidget(self.but_save_cfg)
        self.hbox2.addStretch(1)
        self.hbox2.addWidget(self.but_quit)
        #self.setLayout(self.hbox2)


    def setHBox2ButsVisible(self, is_visible=True):
        self.but_help  .setVisible(is_visible)
        self.but_logger.setVisible(is_visible)
        self.but_quit  .setVisible(is_visible)
        #self.but_save  .setVisible(is_visible)



    def setFrame(self):
        self.frame = QtWidgets.QFrame(self)
        self.frame.setFrameStyle( QtWidgets.QFrame.Box | QtWidgets.QFrame.Sunken ) #Box, Panel | Sunken, Raised
        self.frame.setLineWidth(0)
        self.frame.setMidLineWidth(1)
        self.frame.setGeometry(self.rect())
        #self.frame.setVisible(False)


    def showImage(self, is_visible=True):

        self.wimg.setVisible(is_visible)
        self.setHBox2ButsVisible(is_visible)

        if is_visible :
           #self.setGeometry(50, 10, 620, 620)
           self.setMinimumHeight(620)
           self.setMaximumHeight(2000)
        else :
           self.setFixedHeight(360)
           self.resize(600,360)


    def setParent(self,parent) :
        self.parent = parent

    def resizeEvent(self, e):
        #logger.debug('resizeEvent', self.name)
        self.frame.setGeometry(self.rect())
        #print 'resizeEvent: %s' % str(self.size())
        self.lb_resize.emit()


    def moveEvent(self, e):
        pass


    def closeEvent(self, event):
        logger.debug('closeEvent', self.name)
        if  cp.guilogger != None :
            cp.guilogger.close()
            #del cp.guilogger
            cp.guilogger = None

        if  cp.guihelp   != None :
            cp.guihelp.close()
            #del cp.guihelp
            cp.guihelp = None

        #try    : cp.guilogger.close()
        #except : pass

        #print '%s.closeEvent()' % self.name

        self.notification('stop')


    def notification(self, msg=''):
        pass

    def on_but_quit(self):
        logger.debug('on_but_quit', self.name )
        self.on_but_save_cfg()
        self.close()


    def onEdit(self):
        plogger.debug('onEdit %s', self.name)
        for [lab, edi, par] in self.list_of_fields :
            if edi.isModified() :
                edi.setModified(False)
                par.setValue(str(edi.displayText()))
                plogger.debug('Set the local value of %s to %s for %s', str(lab.text()), par.value(), self.name )

    def onEditMessage(self):
        #"""Do nothing at edition time. Text is picked-up at submission ans saving"""
        #pass
        #print 'Text msg is updated'
        self.updateLocalParMsg()
        self.set_but_reset()

    @QtCore.pyqtSlot(str)
    def tagCompleted(self, newtag):
        if(newtag.startswith("run")):
            try:
                run_num = int(newtag.replace("run", ""))
                plogger.debug("Run number is %s", run_num)
                self.run.setValue(str(run_num))
                self.edi_run.setText(self.run.value())
            except ValueError:
                plogger.error("Cannot parse run number %s", newtag)
            return
        newtags = list(set(self.tag.value().split(" ") + [ "#" + newtag ]))
        self.tag.setValue(" ".join(newtags))
        self.edi_tag.setText(self.tag.value())

    @QtCore.pyqtSlot()
    def firstCharacterTyped(self):
        plogger.debug("The first character was typed in the message box.")
        # We no longer expire the tags until submission.
        self.edi_tag.setProperty("expiration_time", None)
        current_tags = self.list_of_tags()
        self.completer.setTags(current_tags)

        self.__set_dynamic_property__(self.but_elog, "hintNext", True)
        self.__set_dynamic_property__(self.but_grab, "hintNext", False)

    @QtCore.pyqtSlot()
    def tag_timer_tick(self):
        plogger.debug("Timer tick....")
        def clearTagIfTimeOut(tw):
            if("expiration_time" in tw.dynamicPropertyNames()) and tw.property("expiration_time"):
                expiration_time = tw.property("expiration_time")
                plogger.debug("Expiration time: %s", expiration_time)
                if datetime.now() > expiration_time:
                    plogger.debug("Tag expiration; clearing tag %s", tw.text())
                    tw.setText("")
                    self.tag.setValue('')
        clearTagIfTimeOut(self.edi_tag)


    def updateLocalParMsg(self):
        self.msg.setValue(str(self.edi_msg.document().toPlainText()))


    @QtCore.pyqtSlot(int)
    def on_box_exp(self, ind):
        #print 'on_box_exp'
        if not self.box_exp.isEnabled() : return
        exp_selected = self.box_exp.currentText()
        self.exp.setValue(exp_selected)
        self.lbws.set_experiment(exp_selected)

    @QtCore.pyqtSlot(int)
    def on_tag_timeout_change(self, ind):
        if not self.box_tagtimeouts.isEnabled() : return
        self.tag_timeout_index = ind
        plogger.debug("Setting tag timeout to %s", self.tag_timeouts[self.tag_timeout_index])

    def on_but_currexp(self):
        if self.lbws is None : return

        exp_current = self.lbws.get_current_experiment()
        self.list_of_exps = self.lbws.get_list_of_experiments()
        self.exp_ind_in_list = self.list_of_exps.index(exp_current) if (exp_current in self.list_of_exps) else 0

        #print 'exp_current     : ', exp_current
        #print 'list_of_exps    : ', self.list_of_exps
        #print 'exp_ind_in_list : ', self.exp_ind_in_list

        self.lbws.set_experiment(exp_current)
        self.exp.setValue(exp_current)

        self.box_exp.setEnabled(False)
        self.box_exp.clear()
        self.box_exp.addItems(self.list_of_exps)
        self.box_exp.setCurrentIndex(self.exp_ind_in_list)
        self.box_exp.setEnabled(True)

    def set_but_save_visibility(self):
        if self.wimg.r_pixmap is None :
            self.but_save.setVisible(False)
        else :
            self.but_save.setVisible(True) # self.cbx_more.isChecked())


    def printListOfFields(self):
        for [lab, edi, par] in self.list_of_fields :
            print('%15s parameter: %15s    local: %15s' % (lab.text(), par.value()))


    def set_but_reset(self):
        #logger.info('set_but_reset', self.name)

        if self.wimg.isVisible() :
            self.but_reset.setText('&Clear Img')
            self.but_reset.setVisible(True)
            self.but_load.setVisible(False)

        elif self.msg.value() != '' :
        #elif not str(self.edi_msg.document().toPlainText()) != '' :
            self.but_reset.setText('&Clear Msg')
            self.but_reset.setVisible(False)

        else :
            self.but_reset.setText('&Clear')
            self.but_reset.setVisible(False)

#-----------------------------

    def __set_dynamic_property__(self, wdgt, propname, propval):
        """
        Set a dynamic property and reapply the widget's style.
        """
        wdgt.setProperty(propname, propval)
        wdgt.style().unpolish(wdgt)
        wdgt.style().polish(wdgt)


    def on_but_grab(self):
        logger.info('Grab image of current monitor', self.name)
        if self.wimg != None :
            with BtnStatusCtxMgr(self, "Grabbing window") as s:
                self.repaint()
                #------------
                self.wimg.grabImage()
                self.showImage(is_visible=True)
                self.set_but_save_visibility()
                self.set_but_reset()
                #------------

            plogger.debug("Restarting the tag expiration timer")
            self.edi_tag.setProperty("expiration_time", datetime.now() + timedelta(seconds=self.tag_timeouts[self.tag_timeout_index]*60))
            self.__set_dynamic_property__(self.but_grab, "hintNext", False)
            self.__set_dynamic_property__(self.but_elog, "hintNext", True)


    def on_full_screen_grab(self):
        logger.info('Grab image of full screen', self.name)
        if self.wimg != None :
            with BtnStatusCtxMgr(self, "Grabbing full screen") as s:
                self.repaint()
                #------------
                self.wimg.grabFullScreen()
                self.showImage(is_visible=True)
                self.set_but_save_visibility()
                self.set_but_reset()
                #------------

            plogger.debug("Restarting the tag expiration timer")
            self.edi_tag.setProperty("expiration_time", datetime.now() + timedelta(seconds=self.tag_timeouts[self.tag_timeout_index]*60))
            self.__set_dynamic_property__(self.but_grab, "hintNext", False)
            self.__set_dynamic_property__(self.but_elog, "hintNext", True)


    def on_but_reset(self):
        if self.wimg.isVisible() :
            logger.info('Reset/clear image', self.name)
            self.wimg.resetImage()
            self.showImage(is_visible=False)
            self.set_but_save_visibility()

        #elif str(self.edi_msg.document().toPlainText()) != '' :
        elif self.msg.value() != '' :
            #print 'RESET MSG HERE'
            self.edi_msg.setText('')
            self.updateLocalParMsg()

        else :
            pass

        self.edi_msg.resetFirstCharacterDone()
        self.set_but_reset()


    def on_but_load(self):
        logger.info('Select file name and Load image from file', self.name )
        path = get_open_fname_through_dialog_box(self, self.ifname, 'Select file with text image',
               filter='Images (*.ppm *.bmp *.jpg *.jpeg *.png *.xbm *.xpm *.gif *.pbm *.pgm)\nAll files (*)')
              #filter='*.ppm *.bmp *.jpg *.jpeg *.png *.xbm *.xpm *.gif *.pbm *.pgm;')
        if path == None or path == '' :
            logger.info('File name is empty, loading is cancelled...', self.name )
            return

        #print 'Selected file name: ' + path
        print('Selected file name: %s' % path)
        self.wimg.loadImageFromFile(path)
        self.ifname = path
        cp.img_infname.setValue(path)
        self.showImage(is_visible=True)
        self.set_but_save_visibility()
        self.set_but_reset()


    def on_but_save(self):

        if self.wimg.r_pixmap is None :
            path = ''
            logger.warning('Image is empty, there is nothing to save. Saving is cancelled...', self.name )
            return

        logger.info('Select file name and save image in file', self.name )

        path = self.ofname
        #dir, fname = os.path.split(path)
        path  = str( QtWidgets.QFileDialog.getSaveFileName(self,
                                                       caption='Select file to save the plot',
                                                       directory = path,
                                                       filter = '*.ppm *.bmp *.jpg *.jpeg *.png *.pbm *.pgm *.xbm *.xpm'
                                                       ) )
        if path == '' :
            logger.warning('File name is empty, saving is cancelled.', self.name )
            return

        logger.info('Save image in file: ' + path, self.name )
        self.wimg.saveImageInFile(path)
        self.ofname = path
        cp.img_oufname.setValue(path)

#-----------------------------

    def submission_is_allowed(self):
        """Check for timeoot to prevent double-clicking on Submit button"""
        t_click = time()
        if self.time_of_last_click is None:
            self.time_of_last_click = t_click
            return True

        dt = t_click-self.time_of_last_click
        #print 'dt = ', dt
        if dt > self.time_out_double_click :
            self.time_of_last_click = t_click
            return True

        return False

#-----------------------------
    def on_but_elog(self):
        with BtnStatusCtxMgr(self, "Posting to eLog") as s:
            self.__submit__(False)

    def on_but_elog_ins(self):
        with BtnStatusCtxMgr(self, "Posting to eLog") as s:
            self.__submit__(True)

    def on_but_jira_issue(self):
        """
        Log a JIRA issue in addition to submitting to the eLog and instrument eLog.
        """
        with BtnStatusCtxMgr(self, "Posting to eLog") as s:
            self.__submit__(True, open_JIRA_ticket=True)

    def __submit__(self, submit_to_instrument_elog, open_JIRA_ticket=False):

        if not self.submission_is_allowed() : return

        logger.info('Send message to ELog:', self.name )

        if self.wimg.r_pixmap is None :
            path = ''
            logger.warning('1. Image is empty, message will be sent w/o attachement', self.name )
        else :
            file =tempfile.NamedTemporaryFile(mode='r+b',suffix=('.png' if self.hi_quality.isChecked() else '.jpeg')) # '.png')
            path = file.name # self.ofname
            logger.info('1. Save image for attachement in temporary file: ' + path, self.name )
            plogger.info("Saved attachment in %s", path)
            self.wimg.saveImageInFile(path)

        self.msg.setValue(str(self.edi_msg.document().toPlainText()))

        exp = self.exp.value()
        tags = " ".join([re.compile("^#").sub("", x) for x in self.tag.value().split(" ") ])
        if open_JIRA_ticket:
            tags = tags + " ISSUE"
        plogger.debug("Tags: %s ", tags)
        run = self.run.value()
        res = None
        msg = self.msg.value() # str(self.edi_msg.document().toPlainText())

        logger.info('2. Submit message to ELog', self.name )

        log_text = self.get_text_of_msg_parameters(msg, run, res, tags, path)
        logger.info('ELog submission parameters:'+log_text, self.name )

        if not self.is_valid_message(msg) :
            return

        submitter = self.submitter.value().strip()
        if not submitter or submitter == "":
            self.submitter.setValue(self.usr.value())
            self.edi_sbm.setText(self.usr.value())
            raise Exception(f"Cannot use a blank submitter; please use a valid userid.")
        plogger.info(f"Submitting as {submitter}")
        if submitter and len(submitter) == 6 and submitter.endswith("opr") and (submit_to_instrument_elog or open_JIRA_ticket):
            raise Exception(f"Cannot submit to instrument elog/JIRA with an operator account. Please override the submitter {submitter}. If you have typed in a valid submitter, it may be that you just need to focus out of the textbox for the changes to take effect.")

        if submitter and not (len(submitter) == 6 and submitter.endswith("opr")):
            try:
                pwd.getpwnam(submitter)
            except KeyError:
                raise Exception(f"The submitter {submitter} does not exist; please use a valid submitter")

        msg_id = 0
        link_2_msg = ""
        if self.lbws is not None :
            plogger.debug("Run %s", run)
            result = self.lbws.post(msg, run, res, tags, path, submitter=submitter)
            plogger.debug('Response of submission: %s %s', str(result), self.name )

            msg_id = self.get_msg_id_from_result(result, comment='')
            link_2_msg = re.compile("/ws.*/").sub("/", self.lbws.url) + "/lgbk/" + self.lbws.exp + "/elogs/" + msg_id
            plogger.info("Link to eLog message is %s", link_2_msg)
            if not result.get('success', True):
                plogger.error('Response of submission failed: %s %s', str(result), self.name )
                return



            #NORMAL: result: {'status': 'success', 'message_id': '125263'}
            #ERROR:  result: {'status': 'error', 'message': 'Run number 285 has not been found. Allowed range of runs is: 2..826.'}

        # Submit copy of the message to the instrument ELog
        # MMMMMMMMMMMMMMMMM
        if submit_to_instrument_elog and self.lbws2 is not None :
            run, res = '', ''
            lst_tag = tags + " " + exp
            msg2_id = 0

            log_text = self.get_text_of_msg_parameters(msg, run, res, lst_tag, path)
            logger.info('Instrumental ELog parameterss:'+log_text, self.name )

            result2 = self.lbws2.post(msg, run, res, lst_tag, path, submitter=submitter)
            msg2_id = self.get_msg_id_from_result(result2, comment='Responce of submission to instrumental ELog: ')

        self.on_but_reset()

        self.reset_fields_after_submission()

        self.count_msgs += 1

#-----------------------------

    def reset_fields_after_submission(self) :
        self.run.setValue('')
        self.res.setValue('')
        self.msg.setValue('')
        self.submitter.setValue(self.usr.value())
        self.edi_msg.setText(self.msg.value())
        self.edi_run.setText(self.run.value())
        self.edi_sbm.setText(self.usr.value())
        self.edi_tag.setProperty("expiration_time", datetime.now() + timedelta(seconds=self.tag_timeouts[self.tag_timeout_index]*60))
        self.__set_dynamic_property__(self.but_elog, "hintNext", False)
        self.__set_dynamic_property__(self.but_grab, "hintNext", True)
        self.edi_msg.resetFirstCharacterDone()
        self.edi_msg.setFocus()
        self.hi_quality.setChecked(False)
        for ck in self.xpost_checkboxes:
            ck.setChecked(False)

#-----------------------------

    def get_msg_id_from_result(self, result, comment='') :

        if result['success']:
            msg_id = str(result['value']['_id'])
            logger.info(comment + 'New message ID:'+msg_id, self.name )
            return msg_id

        else :
            #print 'Error:', result['message']
            resp = str(result.get('errormsg', ""))
            confirm_dialog_box(self, text='Message to ELog is not submitted.\n' + resp)
            msg_id = ''
            return msg_id

#-----------------------------

    def is_valid_message(self, msg_text) :
        if self.run.value() != '' and self.res.value() != '' :

            msg = "Inconsistent input, submission to ELog is cancelled:" \
                  "\nRun number can't be used togher with the parent message ID." \
                  "\nChoose the right context to post the screenshot and try again."

            confirm_dialog_box(self, text=msg)
            return False

        if msg_text == '' :
            msg = 'Inconsistent input, submission to ELog is cancelled:' \
                  '\nMessage box is empty.' \
                  '\nPlease add your comment in the "Message" box.'
            confirm_dialog_box(self, text=msg)
            return False

        else :
            return True

#-----------------------------

    def get_text_of_msg_parameters(self, msg, run, res, tag, att) :
        list_of_tits = ['msg', 'run', 'res', 'tag', 'att']
        list_of_pars = [ msg,   run,   res,   tag,   att]
        log_text = ''
        for tit,par in zip(list_of_tits, list_of_pars) :
            log_text += '\n   %5s : ' % (tit) + str(par)
        return log_text

#-----------------------------

    def on_but_save_cfg(self):
        logger.debug('on_but_save_cfg',  self.name )
        cp.elog_post_tag.setValue(self.tag.value())
        cp.saveParametersInFile( cp.fname_cp )


    def on_but_logger (self):
        logger.debug('on_but_logger',  self.name )
        #try  :
        if cp.guilogger!=None :
            cp.guilogger.close()
            #self.but_logger.setStyleSheet(cp.styleButtonBad)
            cp.guilogger=None
            logger.info('Logger GUI window is closed',  self.name )
        #except :
        else :
            #self.but_logger.setStyleSheet(cp.styleButtonGood)
            cp.guilogger = GUILogger()
            cp.guilogger.move(self.pos().__add__(QtCore.QPoint(self.size().width()+10,0))) # open window with offset w.r.t. parent
            cp.guilogger.show()
            logger.info('Logger GUI window is open',  self.name )


    def on_but_help(self):
        msg = str(self.help_msg)
        if  cp.guihelp is None :
            cp.guihelp = help_dialog_box(self, text=msg)
        else :
            cp.guihelp.close()
            #del cp.guihelp
            cp.guihelp = None

        #logger.info('Help message:' + msg, self.name )
        #print msg

    def on_but_daqami_crashed(self):
        """
        Log the fact that the DAQ/AMI crashed. We take a full screen show and post it to the Controls experiment.
        """
        fname = tempfile.NamedTemporaryFile(mode='r+b',suffix='.png')
        if( 0 != os.system('import -trim -frame -border -window root %s' % (fname.name))) :
            plogger.debug("Cannot capture the full screen image")
            return
        try:
            resp = submit_msg_to_elog(self.lbws.url, None, None, "OPS", 0, "Computing", self.opts.cmd, [], lst_tag=[self.exp.getValue(), "AMI_DAQ_Issue"], msg="AMI/DAQ issue in experiment %s %s user %s on machine %s" % (self.exp.getValue(), self.opts.inssta, getpass.getuser(), platform.node()), lst_fname=[fname.name])
            plogger.debug(resp)
        except:
            plogger.exception("Exception posting a DAQ/AMI log message")

    def on_hiquality_clicked(self):
        """
        If selected, we post a uncompressed high quality version of the image to the eLog.
        This can increase the size of the image by 7 times.
        """
        plogger.info("Posting a " + ( "high" if self.hi_quality.isChecked() else "medium" ) + " quality image")
        self.wimg.setHiQualityImage(self.hi_quality.isChecked())
        pass

    def on_xpost_clicked(self):
        """
        A cross posting checkbox was clicked
        """
        # print("Cross posting from " + self.sender().property("elog") + " new state " + str(self.sender().isChecked()))
        pass

    def help_message(self):
        msg  = '\n' + '='*60
        msg += '\nMouse control functions in graphical window:'
        msg += '\nZoom-in image: left/right mouse button click, move, and release in another image position.'
        msg += '\nUndo:          middle mouse button click on image - undo up to 10 latest zoom-ins.'
        msg += '\n"Clear" button - clears the image.'
        return msg

#-----------------------------

def test_GUIGrabSubmitELog() :
    app = QtGui.QApplication(sys.argv)
    widget = GUIGrabSubmitELog ()
    widget.show()
    app.exec_()

#-----------------------------

def check_pwd(opts, args):
    if opts.pas is not None : return
    suffix = opts.url.rsplit('-',1)[-1] # splits 'auth', 'pam', or 'kerb'
    if 'kerb' in suffix: return

    msg = 'To use %s and submitt messages in ELog' % os.path.basename(sys.argv[0])\
         +'\nauthentication of user "%s" is required.\n\nPassword:' % opts.usr
    text, ok = QtWidgets.QInputDialog().getText(None, 'Authentication', msg, QtWidgets.QLineEdit.Password)
    #print 'Dialog results: %s %s' % (text, ok)

    if ok :
        opts.pas = text
    else  :
        msg = 'Sorry, %s can not proceed without user "%s" authentication.' % \
              (os.path.basename(sys.argv[0]), opts.usr)
        sys.exit(msg)

#-----------------------------

def check_input_pars(opts, args):
    #print 'opts:\n', opts
    #print 'args:\n', args
    if opts.usr is None :
        import getpass
        uname = getpass.getuser()
        print('WARNING: User name is not specified. By default will use login name "%s".' % (uname))
        opts.usr = uname

    check_pwd(opts, args)

#-----------------------------

from optparse import OptionParser

def input_options_parser() :

    msg_usg  = '  %prog [options] args\n'\
             + 'Example for usr: %prog -i AMO:0 -e amodaq14 -u <login-name> # password will be requested for authentication\n'\
             + 'Example for opr: %prog -i AMO:0 -e amodaq14 -u amoopr -w https://pswww.slac.stanford.edu/ws-auth/lgbk'
    #         + 'Example: /reg/g/pcds/pds/grabber/bin/%prog -i AMO:0 -e amodaq14 -u amoopr -w https://pswww.slac.stanford.edu/ws-auth'

    url_lst = ('https://pswww.slac.stanford.edu/ws-auth/lgbk',
               'https://pswww.slac.stanford.edu/ws-kerb/lgbk')
    url_str = '\n'.join(url_lst)
    url_def = url_lst[1]

    # this should be pulled from DB
    lowered_hutches = [
        'asc',
        'rix',
        'tmo',
        'txi',
        'ued'
    ]

    uppered_hutches = [
        'CXI',
        'DET',
        'DIA',
        'EXT',
        'MEC',
        'MFX',
        'MOB',
        'OPS',
        'PRJ',
        'SXR',
        'USR',
        'XCS',
        'XPP'
    ]

    msg_descrip  = '%prog - grabs any selected window on terminal or its part and submits it with message to ELog'

    parser = OptionParser(description=msg_descrip, usage=msg_usg)
    parser.add_option('-i', '--ins', dest='inssta', default=None,   action='store', type='string', help='the name of an instrument and station <INS>[:<station-number>]')
    parser.add_option('-e', '--exp', dest='exp',    default=None,   action='store', type='string', help='the name of experiment')
    parser.add_option('-w', '--url', dest='url',    default=url_def,action='store', type='string', help='the base URL of LogBook web service, default = %s of the list:\n%s' % (url_def,url_str))
    parser.add_option('-c', '--cmd', dest='cmd',    default=None,   action='store', type='string', help='the command for child message - result of this command is attached to the message')
    parser.add_option('-f', '--cfg', dest='cfname', default=None,   action='store', type='string', help='the file name with configuration parameters (by default is not used)')
    parser.add_option('-u', '--usr', dest='usr',    default=None,   action='store', type='string', help='the user name to connect to the web service')
    parser.add_option('-p', '--pas', dest='pas',    default=None,   action='store', type='string', help='the password to connect to the web service (by default is used for opr accounts)')
    parser.add_option('-v', '--verbose', dest='verb', default=False, action='store_true', help='Turn on debug logging')
    #parser.add_option('-q', '--quiet',        dest='verb',                  action='store_false',          help='supress print on console')

    (opts, args) = parser.parse_args()
    if opts.inssta.lower() in lowered_hutches:
        opts.inssta = opts.inssta.lower()
    elif opts.inssta.upper() in uppered_hutches:
        opts.inssta = opts.inssta.upper()

    if opts.exp:
        if " Instrument" in opts.exp:
            opts.exp = opts.exp.replace(" Instrument", "_Instrument")
            plogger.info("Using the _Instrument for the instrument log %s", opts.exp)
        if opts.exp in [ x.lower() + "_Instrument" for x in uppered_hutches]:
            opts.exp = opts.exp.split("_")[0].upper() + "_Instrument"
            plogger.info("Replacing with correct case for instrument log %s", opts.exp)


    return (opts, args)

#-----------------------------
#-----------------------------
#-----------------------------
#-----------------------------

#---------------------------------
# python /reg/g/pcds/pds/grabber/bin/grelog.py -i AMO -e amodaq14 -u amoopr -p <password> -w https://pswww.slac.stanford.edu/ws-auth
# grelog.py -i AMO -e amodaq14 -u amoopr -w https://pswww.slac.stanford.edu/ws-auth
#---------------------------------


def run_GUIGrabSubmitELog() :

    (opts, args) = input_options_parser()

    if opts.verb:
        logging.basicConfig(level=logging.DEBUG, handlers=[logging.StreamHandler()])
    else:
        logging.basicConfig(level=logging.INFO, handlers=[logging.StreamHandler()])

    #-----------------------------
    print('File name for I/O configuration parameters:', str(opts.cfname))

    sta = ''
    pos = opts.inssta.rfind(':')
    if pos==-1 : ins = opts.inssta
    else :
        ins = opts.inssta[:pos]
        if len(opts.inssta[pos:]) > 1 : sta = opts.inssta[pos+1:]

    print('here is instrument! ', ins)
    #-----------------------------

    app = QtWidgets.QApplication(sys.argv)

    fontfile = os.path.abspath(os.path.join(__file__, "..", "..", "static", "PlayfairDisplay-Regular.ttf"))
    plogger.debug("Loading font file %s", fontfile)
    id = QtGui.QFontDatabase.addApplicationFont(fontfile)
    if id >= 0:
        plogger.debug("Using Playfair Font")
        app.setFont(QtGui.QFont(QtGui.QFontDatabase.applicationFontFamilies(id)[0], 10))

    with open(os.path.abspath(os.path.join(__file__, "..", "..", "static", "lgbk.css")), 'r') as f:
        app.setStyleSheet(f.read())


    check_input_pars(opts, args)

    #-----------------------------
    pars = { 'ins'    : ins,
             'sta'    : sta,
             'exp'    : opts.exp,
             'url'    : opts.url,
             'usr'    : opts.usr,
             'pas'    : opts.pas,
             'cmd'    : opts.cmd
           }

    print('Start grabber for ELog with input parameters:')
    for k,v in list(pars.items()):
        if k != 'pas' : print('%9s : %s' % (k,v))

    lbws = LogBookWebService(**pars)
    #lbws.print_experiments()

    #-----------------------------
    pars2 ={ 'ins'    : 'OPS',
             'sta'    : sta,
             'exp'    : ins + ' Instrument',
             'url'    : opts.url,
             'usr'    : opts.usr,
             'pas'    : opts.pas,
             'cmd'    : opts.cmd
           }

    print('Open web service for copy messages in the instrumental ELog:')
    for k,v in list(pars2.items()):
        if k != 'pas' : print('%9s : %s' % (k,v))

    lbws2 = LogBookWebService(**pars2)
    #lbws2.print_experiments()

    #-----------------------------
    #app = QtGui.QApplication(sys.argv)
    #w  = GUIGrabSubmitELog.py(**pars)
    w = GUIGrabSubmitELog(cfname=opts.cfname, lbws=lbws, lbws2=lbws2, opts=opts)
    w.show()
    #w.dumpObjectTree()
    app.exec_()

    #del QtGui.qApp
    #QtGui.qApp=None

    #app.closeAllWindows()
    #QtGui.qApp=None
    print('Exit application...')

#-----------------------------
#-----------------------------
#-----------------------------
#-----------------------------

if __name__ == "__main__" :

    plogger.debug("Starting the application")

    if len(sys.argv)==1 :
        sys.argv.append('-h')
        run_GUIGrabSubmitELog()

    elif len(sys.argv)==2 or len(sys.argv)==3 :

        if   sys.argv[1] == '-h': run_GUIGrabSubmitELog()
        elif sys.argv[1] == '1' : test_Logger()
        elif sys.argv[1] == '2' : test_ConfigParametersForApp()
        elif sys.argv[1] == '3' : test_GUILogger()
        elif sys.argv[1] == '4' : test_GUIImage()
        else : print('Non-recognized argument: %s' % sys.argv[1])

    else :
        run_GUIGrabSubmitELog()

    sys.exit ('End of %s' % sys.argv[0])

    #try: sys.exit (0)
    #except SystemExit as err :
    #    print 'Xo-xo'

#-----------------------------
#-----------------------------
